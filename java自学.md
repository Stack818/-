 # java基础（JavaSe）

## 建立编程思想

---

### 一些小细节

* 一个源文件中只有一个public类其他类不限制，编译以后每一个类都会生成一个.class文件

* Java的应用执行入口是main方法固定的书写格式：

* ``` jav
  public static void main(String[] args){}
  ```

* 如果源文件包含一个public类，则文件名必须和public类的名字同名

* 在非public类的类中也可以写main方法，只需指定非public类，这样入口方法就是非public的主方法

* 业务错误，环境错误比较麻烦！！！

### 文档注释

1. Javadoac 解析的，生成的一套以网页形式体现的该程序的说明文档

2. 格式：/** 标签  */

3. ```java
   javadoc -d 文件名 -xx -yy dem.java
   ```

4. ![image-20230918165008131](C:\Users\26251\AppData\Roaming\Typora\typora-user-images\image-20230918165008131.png)

5. 类，方法的注释使用Javadoc 来写



### 数据类型

 1. 基本数据类型

    * 数值型：浮点，整形

    * 字符

    * 布尔（无强制转换）

      2. 引用数据类型

      * 类
      * 接口
      * 数组

    

### Java文档

1. API ：应用程序接编程接口
2. Java类的组织形式 ：![image-20230919211404336](C:\Users\26251\AppData\Roaming\Typora\typora-user-images\image-20230919211404336.png)
3. 按照包找到类或者直接搜索

### 基本数据类型与String类型的转换：

1. 基本类转String ：将基本类的值 + " " 即可
2. String类转基本类：通过基本类的包装类调用parseXX方法即可

> 注意：在String转基本类型时要确保可行，否则执行时抛出异常，终止程序

> % 运算符在遇到 a % b 中a是小数时计算公式为
>
> ``` java 
> a % b = a - (int)a / b * b;
> ```
>
> 注意：小数运算中得到的值为近似值！！



随机数生成：Math.random() 生成 (0,1)内的随机数

### 类与对象

对象[属性，方法]；

对象在内存中的存放形式：![image-20230920093904696](C:\Users\26251\AppData\Roaming\Typora\typora-user-images\image-20230920093904696.png)



> 方法细节：方法不能嵌套定义；
>
> 同一类的方法可以直接调用，跨类方法调用中需要通过对象名调用，比如 对象名.方法名(参数);需注意的时跨类调用时要考虑访问修饰符的问题。
>
> 方法传递参数中：对于基本类型为值传递，引用类型为传递地址
>
> 方法递归调用：执行一个方法时，就创建一个新的受保护的独立空间（栈），如果方法中使用的是引用类型变量，就会共享该引用变量，递归必须向退出方向推进

### 方法重载（overload）

同一类中允许有多个同名方法，但要求形参不一样，返回参数没影响

### 可变参数

> 为了解决同名方法功能相同，参数个数不同->使用可变参数优化！
>
> 可变参数的形参可以是数组，可变参数的实质就是数组
>
> 可变参数可以和普通参数一起放在形参列表，但是要放在最后，且只能有一个可变参数

``` java 
class m{
    public int sum(int... sums)
    {
        //sums 相当于数组，个数从0-n
    }
}
```

### 作用域

> 全局变量就是属性，局部变量就是除了属性之外的变量
>
> 全局变量（属性）如果不赋值可以直接使用，有默认值，局部变量没有默认值，不能直接使用。
>
> 属性和局部变量可以重名，访问时遵循就近原则
>
> 属性可以加修饰符，局部变量不能加修饰符

### 构造器（constructor）

>语法：[修饰符]方法名(形参列表){	方法体	}
>
>作用: 完成对新对象的初始化，方法名必须和类同名，没有返回值，
>
>一个类的构造器可以重载，规则和重载相同，如果自己不写构造器，系统会自动给类生成一个默认的无参构造器，一旦定义了自己的构造器，默认的构造器就被覆盖了，，这时候需要显示定义一下无参构造器。

### 对象创建的流程

> 1. 加载类信息（XX.class），只会加载一次
> 2. 在堆中分配空间（地址）
> 3. 完成对象初始化【3.1默认初始化3.2显示初始化3.3构造器的初始化】
> 4. 在对象在堆 中地址，返回给P;(P 是对象的引用)

### this关键字

> 每个对象都有自己的this。this代表当前对象，相当于一个引用指向自己。
>
> 哪个对象调用，就是哪个对象的this。、
>
> this可以访问本类的属性，方法，构造器。
>
> 访问成员的语法： this.方法名(参数列表)
>
> 访问构造器的语法：this(参数列表)；注意只能在构造器中使用，如果有this() ，必须置于第一条语句
>
> this不能再类定义的外部使用
>
> 重要性 体现在继承

### 包

>
>
>区分相同的类；当类很多的时候，就可以很好的管理类；控制访问范围；
>
>语法：package 关键字，表示打包；com.hspeedu表示包名
>
>``` java 
>package com.hspedu;
>```
>
>包的本质就是文件夹；创建不同的文件夹来保存类文件；
>
>包的命名：只能包含数字，字母，下划线，小圆点；但不能用数字开头；不能是关键字或者保留字；一般是小写字母+小圆点：com.公司名.项目名.业务模块名
>
>常用的包：
>
>1. java.lang 默认导入，不需要导入
>2. java.util 系统提供的工具包，工具类，。。。使用Scanner
>3. java.net 网络包，网络开发
>4. java.awt 是做java 的界面开发,GUI
>
>导入包：import  语法
>
>```java 
>import java.util.Scanner; //表示只会引入java.util包下面的Scanner
>import java.util.* //表示引入java.util包下的所有类
>//建议需要哪一个类就导入哪个类即可，不建议 * 的导入
>```
>
>package 语句需要放在类或文件的最上面，一个类族最多一个package；
>
>import 语句放在package 语句下面，在类定义之前，可以有多条，且没有顺序要求。

### 访问修饰符

>访问修饰符：控制属性和方法的访问范围，：public(对外公开)，protected(受保护级别同一包)，默认(只有同一个包才能访问)，private(私有,同一个类访问)<img src="C:\Users\26251\AppData\Roaming\Typora\typora-user-images\image-20230924223510930.png" alt="image-20230924223510930" style="zoom:50%;" />
>
>细节：
>
>1. 也可以修饰类 ： 只有默认和 pubic 。
>2. 

### 封装

>1. 隐藏实现细节 方法（连接数据库）
>2. 可以对数据进行验证，保证合理安全
>3. 实现步骤：
>   1. 将属性私有化
>   2. 提供一个共有的pubic set()方法，用于对属性的判断并赋值；以及一个 public get()方法,用于对属性的值的获取；
>   3. 快捷键输入 Alt+Ins;
>4. 和构造器的结合：将set()方法写入构造器中；

### 继承

>1. 代码复用
>
>2. 语法： class 子类 extends 父类{
>
>   }
>
>3. 子类自动继承父类的方法，但是私有属性和方法不能直接访问，要通过公共的方（）去访问；非私有的属性和方法可以直接访问。
>
>4. 子类必须调用父类的构造器完成对父类的初始化当创建子类对象时，不管使用哪一个子类的构造器，默认情况下//super()；总会调用父类的无参构造器，如果父类没有提供无参构造器，则必须在子类中用super指定使用父类的哪个构造器完成对父类的初始化工作，否则，编译不通过。
>
>5. 如果希望调用父类的某个构造器，则显式的调用一下。
>
>6. super() 在调用时必须放在构造器的最前面。
>
>7. super()和this() 都只能放在构造器的第一行，因此这两个方法不能共存。
>
>8. 所有的类都是Object的子类。
>
>9. 父类构造器的调用不限于直接父类，将一直往上追溯到Object类。
>
>10. 子类最多只能有一个父类：单继承机制；
>
>11. 不能滥用继承，必须满足is-a 关系。
>
>12. 继承的内存分布：<img src="C:\Users\26251\AppData\Roaming\Typora\typora-user-images\image-20230925111323847.png" alt="image-20230925111323847" style="zoom:50%;" />
>
>13. 如上图所示：在调用一个属性时，要按照查找关系来返回信息的，
>
>    14. 首先看子类是否有这个属性；
>
>    15. 如果子类有这个属性，并且可以访问，则返回信息
>
>    16. 如果子类没有这个属性，就看父类有没有这个属性(如果父类有该属性并且可以访问，就返回)
>
>    17. 如果父类没有就按照3.的规则继续向上查找父类，知道Object...
>
>    18. #### 需要注意如果父类有该属性但被private起来他并不会跳过该父类继续向上，而是直接报错。

### super()

1. 代表父类的引用，用于访问父类的构造器，方法，属性

2. 访问父类的属性和方法，但不能访问private修饰的

3. super()的便利好处：

   1. 调用父类的构造器的好处，分工明确
   2. 当子类和父类的成员重名时，为了访问父类的成员，必须通过super。
   3. super() 的访问不限于直接父类，如果爷类和本类中有同名的成员，也可以使用super去访问爷爷类 的成员；如果 多个基类中都有同名的成员，使用时遵循就近原则，当然也需要遵守访问权限的相关规则。

### 方法重写

1. 子类的方法的参数和方法名称要和父类的一致，
2. 子类方法的返回类型和父类的返回类型一样，或者父类返回类型的子类。比如：父类返回类型是Object子类返回类型是String。
3. 子类方法不能缩小父类方法的访问权限。   

| 名称 | 发生范围                 | 方法名 | 参数列表 | 返回类型                                           | 修饰符                                 |
| ---- | ------------------------ | ------ | -------- | -------------------------------------------------- | -------------------------------------- |
| 重载 | 一个类中                 | 相同   | 必须不同 | 可以不同                                           | 无要求                                 |
| 重写 | 继承关系的子类和父类之间 | 相同   | 相同     | 可以不同，如果不同则子类必须返回父类返回类型的子类 | 可以不同，但子类不能缩小父类方法的权限 |

### 多态( polymorphic )

1. 方法和对象具有多种形态，是面向对象的第三大特征，多态是建立在封装和继承基础上的。

2. 方法重载体现多态；方法重写体现多态；

3. 对象的多态(核心)
   1. 一个对象的编译类型和运行类型可以不一致；
   2. 编译类型在定义对象时就确定了，不能改变，
   3. 运行类型时可以变化的。
   4. 编译类型看定义时 = 号的左边，运行类型看 = 的右边
   5. 笑话：披着羊皮的狼

4. 细节：

   1. 首先要存在继承关系

   2. 多态向上转型（父类的引用指向子类的对象，）

   3. 语法 ： 父类名  父类引用  = new 子类名() ；

   4. 可以调用父类的所有成员（遵守原则）

   5. 但是不能调用子类的特有成员； 因为在编译阶段能调用那些成员，是由编译类型决定的；

   6. 最终的运行结果还要看子类的具体实现；即调用方法时，从子类开始查找调用方法，就近原则

      ​	

5. 向下转型 

   1. 子类类型  引用名  = （子类类型） 父类引用
   2. 只能强制转父类的引用，不能强转父类的对象。
   3. 要求父类 的引用必须指向当前目标类型的对象
   4. 当向下转型后，就可以调用所有子类的成员。

6. 属性没有重写之说，属性看编译类型。

7. instanceOf() 比较操作符 ，判断对象XX(传入引用的运行类型)的类型是XX类型或者XX类型的子类型。

###  Java的动态绑定机制（DynamicBinding）重要

1. 当调用对象方法时，该方法会和该对象的内存地址/运行类型绑定
2. 当调用对象属性时，没有动态绑定机制，哪里声明那里使用。

---

#### 多态数组

1. 数组的定义为父类类型，里面保存的实际元素类型为子类类型  
2. 想调用子类特有的方法，可以使用 instanceOf() 语句进行判断。

#### 多态参数

1. 方法定义的形参类型是父类类型，实参允许可以为子类类型。

#### object类

1. equals(): 
   1. == 是一个比较运算符，即可以比较基本类型，也可以比较引用类型，如果判断基本类型，为值比较，如果判断引用类型，为地址比较，即判断是否是同一个对象。
   2. equals() 是object 的一个方法，只能判断引用类型，默认判断地址是否相同，子类中常常重写该方法，用于判断内容是否相等。
   3. 重写我们定义的类的equals()；
2. hashCode()；
   1. 提高具有哈希结构的容器的效率
   2. 两个引用，如果指向同一个对象，则哈希值肯定是一样的；
   3. 两个引用，如果指向的是不同对象，则哈希值是不一样的；
   4. 哈希值主要是根据地址号来的，不能完全将哈希值等同于地址。
   5. 后面在集合中hashCode()如果需要的话可以重写。

3. toString();
   1. 默认返回： 全类名+@+哈希值的十六进制，全类名指包名+类名
   2. 子类往往重写toString()方法, 用于返回对象的属性信息。
   3. 重写：快捷键
   4. 当直接输出一个对象时，默认调用toString();

4. finallize()
   1. 当对象被回收时，系统自动调用该对象的fianllize方法，子类可以重写该方法，做一些释放资源的操作；
   2. 什么时候被回收：当某个对象没有任何引用时，则jvm就认为这个对象是一个垃圾对象，就会使用垃圾回收机制来销毁对象，在销毁对象前，会先调用finallize方法
   3. 垃圾回收机制 的调用，是由系统决定的也可以由System.gc()主动触发垃圾回收机制
   4. 实际开发中几乎不会去运用


#### 断点调试

1. 快捷键： F7(跳入)	F8(跳过) 	F9(resume，执行下一个断点)
2. F7：跳入方法内
3. F8 : 跳出方法
4. 

#### 项目分层分包：程序入口，界面层，业务层，domain,model数据层（各司其职）

### static 类变量，静态变量

1. 语法：访问修饰符 static 数据类型 变量名		/访问修饰符 static 数据返回类型 方法名(){  	}
2. 所有该类的对象都可以访问该属性/方法
3. 当一个属性/方法是static时，他就时静态的属性/方法，// 静态属性/方法可以直接通过类名调用。
4. 在类加载时生成并初始化，关于他实际存储的位置：在jdk8 之前是放在方法区，之后则在类加载时由反射机制在堆中创建一个class 实例的尾部。后面详见。
5. 类对象的生命周期是随着类的加载而开始，随着类的销毁而消失。
6. 类属性细节： 
   1. 什么时候需要类变量 ：当所有对象需要共享一个变量时，就可以考虑使用类变量(静态变量)
   2. 类变量与实例变量的区别：类变量是共享的，而实例变量是每个对象独享的；
   3. 加上static 称为静态变量或类变量，否则称为实例变量/普通变量/非静态变量‘
   4. 类变量可以通过 类名.类（变量名/方法名） 或者 对象名.类(变量名/方法名) 直接调用访问，但跟推荐使用类名调用，（在遵守访问 权限下）
7. 类方法细节：
   1. 类方法和普通方法随着类的加载而加载，即将结构信息存储于方法区：
      1. 类方法中无this 参数
      2. 普通方法中隐含this 的参数
      3. 类方法中不允许使用和对象有关的关键字，比如this 和super 
      4. 静态方法只能访问静态成员，普通方法都可以访问
   2. 类方法的使用场景：当方法中不涉及任何和对象相关的成员，则可以将方法设计为静态方法，提高开发效率// 比如工具类中的方法 utils 
   3. 在开发实际中，开发自己的工具类 ：往往会将一些通用的方法，设计为静态方法，这样我们不需要创建对象实例就可以直接调用！

#### main方法、

1. main方法是Java虚拟机调用的
2. Java虚拟机需要调用mian方法，所以是 public 
3. Java虚拟机在执行main方法时不必创建对象，所以是static 
4. 该方法接受String 类型 的数组参数，该数组中保存执行Java命令时传递的所运行的类的参数
5. ![屏幕截图 2023-10-05 094443](D:\desktop\sugar\history\markdown\new1\video\屏幕截图 2023-10-05 094443.png)
6. 在main 方法中我们可以直接调运main 方法所在类的静态方法或静态属性
7. 但是不能直接访问非静态成员，必须创建一个该类的实例对象后才能通过该对象区访问类中的非静态成员 

#### 代码块

1. 代码化块又称初始化块，属于类的成员（是类的一部分），类似于方法，将逻辑语句封装在方法体中，通过 { } 包围起来。

2. 但和方法不同，没有方法名，没有返回，没有参数，只有方法体，而且不用通过对象或类显式调用，而是在加载类时，或者创建类是隐式调用

3. 语法 ： [修饰符]{  代码 }

4. 修饰符可选，要写只能写static 

5. 分为两类 ，使用static 修饰的叫静态代码块，没有static 修饰的叫普通代码块 

6. 相当于另外一种形式的构造器（ 对构造器的补充机制），可以做到初始化的操作

7. 场景： 如果多个构造器都有重复的语句，可以抽取到初始化块中，提高代码的重用性

8. 细节:

   1.   static 代码块也叫静态代码块，作用是对类对象进行初始化，而且他随着类的加载【 1. 创建对象实例时；2. 创建子类对象实例时，父类也会被加载‘3. 使用类的静态成员时】	而执行，并且只执行一次，如果是普通代码块，没创建一个对象，就执行一次 。
   2.   普通的代码块，在创建对象实例时，会被隐式 的调用，被创建一次，就会调用一次，如果只是使用类的静态成员，普通代码块不会被执行（普通代码在new 对象时，才会被调用，而且每创建一个对象，就被调用一次，和类加载没有关系。）
   3.   创建一个对象时，在  一个类 调用顺序是
        1.   调用静态代码块和静态属性初始化（二者优先级相同，按顺序调用）；
        2.   调用普通代码块和普通属性的初始化（注意：普通代码块和普通属性的初始化（二者优先级相同，按顺序调用）
        3.   调用构造方法

9. 构造器 的最前面其实隐含了 super() 和 调用普通代码块，

10. ``` java 
    class A{
        public A（）{
    		//这里隐藏了执行
            //super()；
            //调用普通代码块
            System.out.println();
        }
    }
    ```

11. 创建子类时（继承关系），他们的静态代码块，静态属性初始化，普通代码块，普通属性初始化，构造方法的调用顺序：

    1.   父类的静态代码块和静态属性

    2.   子类的静态代码块和静态属性

    3.   父类的普通代码块和普通属性

    4.   父类的构造方法

    5.   子类的普通代码块和普通属性

    6.   子类的构造方法

12. 静态代码块只能直接调用静态成员（静态属性和静态方法），普通代码块可以调用任意成员

#### 设计模式

1. 设计模式是在大量的实践中总结和理论化后的代码结构，编程风格，以及解决问题的思考方式
2. 单例设计模式
   1. 即采用一定的方法保证在整个的软件系统中，对某个类只存在一个对象实例，并且该类只提供一个取得其对象实例的方法
   2. 单例模式有 饿汉式 和
      1. 构造器私有化
      2. 类的内部创建对象
      3. 向外暴露一个静态的公共方法
      4. 可能造成创建了对象但没有使用
   3.   懒汉式
      1. 仍然将构造器私有化
      2. 定义一个静态属性(不 new)
      3. 向外暴露一个静态的公共方法 
   4. 二者区别  ：
      1. 二者最主要的区别在于创建对象的时机不同：饿汉式是在类加载就创建了对象实例，而懒汉式是在使用时才创建
      2. 饿汉式不存在线程安全问题，懒汉式存在线程安全问题
      3. 饿汉式存在浪费资源的可能，因为如果程序员一个对象实例都没有使用，那么饿汉式创建的对象就浪费了，懒汉式式使用才创建，就不存在这个问题

#### final关键字

1. 修饰类，属性，方法和局部变量
2. 在某些情况下，
   1.  当不希望类被继承时可以用final修饰。
   2.  当不希望父类的某个方法被子类盖/ 重写(override) 时， 可以用final 修饰。
   3.  当不希望类的的某个属性的值被修改， 可以用final 修饰
   4.  当不希望某个局部变量被修改， 可以使用final 修饰
3. 细节：
   1. fianl 修饰的属性又叫常量
   2. final 修饰的属性在定义时，必须赋初值，并且以后不能再修改，赋值可以在如下位置中:
      1. 定义时
      2. 在构造器中
      3. 在构造器中

   3. 如果final 修饰的属性是静态的，则初始化的位置只能是：
      1. 定义时
      2. 在静态代码块，不能再构造器中赋值

   4. final 类不能继承，但是可以实例化对象。
   5. 如果 类不是final 类，但是含有final 方法，则该方法不能重写，但是可以被继承。
   6. 一般来说，如果一个类已经是final 类，就没有必要再将方法修饰为final 
   7. final 不能修饰构造器
   8. final 和static 往往一起使用，效率更高（不会导致整个类被加载）
   9. 包装类（Integer ，Double ,float,Boolean等都是final ），String 也是final 类。


#### 抽象类

1. 对于父类的不确定性问题

   1. 考虑将方法设计为抽象方法，即没有实现的方法，即没有方法体，一般来说抽象类会被继承，由其子类实现抽象方法

2. 用 abstract关键字修饰语法：

   1. 访问修饰符 abstract  类名{   }
   2. 访问修饰符 abstract 返回类型 方法名（参数列表）； 
   3. 细节： 
      1. 抽象类 不能被实例化
      2. 抽象类不一定包含abstract 方法，也就是说抽象类可以没有abstract 方法
      3. 一旦包含了abstract 方法，则这个类必须声明为abstract 
      4. abstract 只能修饰类和方法，不能修饰属性和其他的
      5. 抽象类可以有任意成员（因为抽象类还是一个类），比如非抽象方法，构造器，静态属性等等
      6. 抽象方法不能有主体，即不能实现
      7. 如果一个类继承了抽象类，则他必须实现抽象类的所有抽象方法，除非他自己也声明为abstract 类
      8. 抽象方法不能使用private 和final  和 static 修饰，应为这些关键字都是和重写相违背的
      9. 抽象类模板设计模式

   #### 接口

   1. 接口就是给出一些没有实现的方法，封装起来，到某个类要使用时，再根据具体情况把这些方法写出来。语法：

      1. ```java 
         interface 接口名{
             //属性
             //抽象类方法
             public void hi();
             default public  void ok(){
                //默认实现方法，需要default 关键字修饰
             }
             public static void cry(){
                 //静态方法	
             }
         }
         class 类名 implements 接口名{
             自己的属性;
             自己的方法;
             必须实现的接口的抽象方法
         }
         ```

   2. 细节：

      1. 接口不能被实例化
      
      2. 接口中所有方法是public方法，接口中抽象方法，可以不用abstract 修饰
      
      3. 一个普通类实现接口，就必须将该接口的所有方法实现;快捷键（AIT + Enter ）
      
      4. 抽象类实现接口，可以不用实现接口的方法
      
      5. 一个类同时可以实现多个接口
      
      6. 接口中的属性，只能是final 的，而且只能是 public static final 修饰符
      
      7. 接口中属性的访问形式：接口名.属性名
      
      8. 一个接口不能继承其他的类，但是可以继承多个别的接口
      
         > ``` java 
         > interface A extends B,C{}
         > ```
      
      9. 接口的修饰符只能是public和默认，这点和类的修饰符相同
      
      10. 接口和继承：
      
          1. 继承的主要价值在于：解决代码的复用性和可维护性；接口的价值在于：设计，设计好各种规范（方法）让其他类去实现这些方法，即更加灵活
          2. 当子类继承了父类，就拥有了父类的功能
          3. 如果子类需要扩展功能，可以通过实现接口的方式扩展
          4. 可以理解为实现接口时对Java 单继承机制的一种补充
          5. 接口再一定程度上实现了代码解耦【接口规范性和动态绑定机制】
      
      11. 多态参数
      
      12. 多态数组

#### 内部类

1. 一个类的内部有完整的嵌套了另一个类的结构，被嵌套的类称为内部类，嵌套其他类的类为外部类。内部类的最大特点是可以直接访问私有属性，并且可以体现类与类的包含关系
2. 四种内部类：
   1. 定义在外部类的局部位置（比如方法内）
      1. 局部变量（有类名）
      2. 匿名内部类（无类名！！！！！！！！）
   2. 定义在外部类的成员位置上
      1. 成员内部类（没有static 修饰）
      2. 静态内部类（使用static 修饰）
3. 局部内部类：
   1. 可以直接访问外部类的所有成员，包含私有的
   2. 不能添加修饰符,但可以使用final 修饰
   3. 作用域：仅在定义他的方法或代码块中
   4. 局部内部类---访问---外部类的成员【访问方式：直接访问】
   5. 外部类---访问---局部内部类的成员【访问方式：创建对象，再访问】，必须再作用域内
   6. 外部其他类---不能访问---局部内部类(地位是一个局部变量)
   7. 如果外部类和局部内部类的成员重名时，默认遵循就近原则，如果想访问外部类的成员，则可以使用（外部类名.this. 成员）

#### 匿名内部类

1. 本质是类；内部类；该类没有名字；同时还是一个对象

2. 语法：  

      1. ``` java
            new 类或接口(参数列表)
            {
                类体
            }；

3.   用处，当做实参直接传递

4. 
















## 提升编程能力



## 分析需求代码实现





