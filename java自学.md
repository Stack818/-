 # java基础（JavaSe）

## 建立编程思想

---

### 一些小细节

* 一个源文件中只有一个public类其他类不限制，编译以后每一个类都会生成一个.class文件

* Java的应用执行入口是main方法固定的书写格式：

* ``` jav
  public static void main(String[] args){}
  ```

* 如果源文件包含一个public类，则文件名必须和public类的名字同名

* 在非public类的类中也可以写main方法，只需指定非public类，这样入口方法就是非public的主方法

* 业务错误，环境错误比较麻烦！！！

### 文档注释

1. Javadoac 解析的，生成的一套以网页形式体现的该程序的说明文档

2. 格式：/** 标签  */

3. ```java
   javadoc -d 文件名 -xx -yy dem.java
   ```

4. ![image-20230918165008131](C:\Users\26251\AppData\Roaming\Typora\typora-user-images\image-20230918165008131.png)

5. 类，方法的注释使用Javadoc 来写



### 数据类型

 1. 基本数据类型

    * 数值型：浮点，整形

    * 字符

    * 布尔（无强制转换）

      2. 引用数据类型

      * 类
      * 接口
      * 数组

    

### Java文档

1. API ：应用程序接编程接口
2. Java类的组织形式 ：![image-20230919211404336](C:\Users\26251\AppData\Roaming\Typora\typora-user-images\image-20230919211404336.png)
3. 按照包找到类或者直接搜索

### 基本数据类型与String类型的转换：

1. 基本类转String ：将基本类的值 + " " 即可
2. String类转基本类：通过基本类的包装类调用parseXX方法即可

> 注意：在String转基本类型时要确保可行，否则执行时抛出异常，终止程序

> % 运算符在遇到 a % b 中a是小数时计算公式为
>
> ``` java 
> a % b = a - (int)a / b * b;
> ```
>
> 注意：小数运算中得到的值为近似值！！



随机数生成：Math.random() 生成 (0,1)内的随机数

### 类与对象

对象[属性，方法]；

对象在内存中的存放形式：![image-20230920093904696](C:\Users\26251\AppData\Roaming\Typora\typora-user-images\image-20230920093904696.png)



> 方法细节：方法不能嵌套定义；
>
> 同一类的方法可以直接调用，跨类方法调用中需要通过对象名调用，比如 对象名.方法名(参数);需注意的时跨类调用时要考虑访问修饰符的问题。
>
> 方法传递参数中：对于基本类型为值传递，引用类型为传递地址
>
> 方法递归调用：执行一个方法时，就创建一个新的受保护的独立空间（栈），如果方法中使用的是引用类型变量，就会共享该引用变量，递归必须向退出方向推进

### 方法重载（overload）

同一类中允许有多个同名方法，但要求形参不一样，返回参数没影响

### 可变参数

> 为了解决同名方法功能相同，参数个数不同->使用可变参数优化！
>
> 可变参数的形参可以是数组，可变参数的实质就是数组
>
> 可变参数可以和普通参数一起放在形参列表，但是要放在最后，且只能有一个可变参数

``` java 
class m{
    public int sum(int... sums)
    {
        //sums 相当于数组，个数从0-n
    }
}
```

### 作用域

> 全局变量就是属性，局部变量就是除了属性之外的变量
>
> 全局变量（属性）如果不赋值可以直接使用，有默认值，局部变量没有默认值，不能直接使用。
>
> 属性和局部变量可以重名，访问时遵循就近原则
>
> 属性可以加修饰符，局部变量不能加修饰符

### 构造器（constructor）

>语法：[修饰符]方法名(形参列表){	方法体	}
>
>作用: 完成对新对象的初始化，方法名必须和类同名，没有返回值，
>
>一个类的构造器可以重载，规则和重载相同，如果自己不写构造器，系统会自动给类生成一个默认的无参构造器，一旦定义了自己的构造器，默认的构造器就被覆盖了，，这时候需要显示定义一下无参构造器。

### 对象创建的流程

> 1. 加载类信息（XX.class），只会加载一次
> 2. 在堆中分配空间（地址）
> 3. 完成对象初始化【3.1默认初始化3.2显示初始化3.3构造器的初始化】
> 4. 在对象在堆 中地址，返回给P;(P 是对象的引用)

### this关键字

> 每个对象都有自己的this。this代表当前对象，相当于一个引用指向自己。
>
> 哪个对象调用，就是哪个对象的this。、
>
> this可以访问本类的属性，方法，构造器。
>
> 访问成员的语法： this.方法名(参数列表)
>
> 访问构造器的语法：this(参数列表)；注意只能在构造器中使用，如果有this() ，必须置于第一条语句
>
> this不能再类定义的外部使用
>
> 重要性 体现在继承

### 包

>
>
>区分相同的类；当类很多的时候，就可以很好的管理类；控制访问范围；
>
>语法：package 关键字，表示打包；com.hspeedu表示包名
>
>``` java 
>package com.hspedu;
>```
>
>包的本质就是文件夹；创建不同的文件夹来保存类文件；
>
>包的命名：只能包含数字，字母，下划线，小圆点；但不能用数字开头；不能是关键字或者保留字；一般是小写字母+小圆点：com.公司名.项目名.业务模块名
>
>常用的包：
>
>1. java.lang 默认导入，不需要导入
>2. java.util 系统提供的工具包，工具类，。。。使用Scanner
>3. java.net 网络包，网络开发
>4. java.awt 是做java 的界面开发,GUI
>
>导入包：import  语法
>
>```java 
>import java.util.Scanner; //表示只会引入java.util包下面的Scanner
>import java.util.* //表示引入java.util包下的所有类
>//建议需要哪一个类就导入哪个类即可，不建议 * 的导入
>```
>
>package 语句需要放在类或文件的最上面，一个类族最多一个package；
>
>import 语句放在package 语句下面，在类定义之前，可以有多条，且没有顺序要求。

### 访问修饰符

>访问修饰符：控制属性和方法的访问范围，：public(对外公开)，protected(受保护级别同一包)，默认(只有同一个包才能访问)，private(私有,同一个类访问)<img src="C:\Users\26251\AppData\Roaming\Typora\typora-user-images\image-20230924223510930.png" alt="image-20230924223510930" style="zoom:50%;" />
>
>细节：
>
>1. 也可以修饰类 ： 只有默认和 pubic 。
>2. 

### 封装

>1. 隐藏实现细节 方法（连接数据库）
>2. 可以对数据进行验证，保证合理安全
>3. 实现步骤：
>   1. 将属性私有化
>   2. 提供一个共有的pubic set()方法，用于对属性的判断并赋值；以及一个 public get()方法,用于对属性的值的获取；
>   3. 快捷键输入 Alt+Ins;
>4. 和构造器的结合：将set()方法写入构造器中；

### 继承

>1. 代码复用
>
>2. 语法： class 子类 extends 父类{
>
>   }
>
>3. 子类自动继承父类的方法，但是私有属性和方法不能直接访问，要通过公共的方（）去访问；非私有的属性和方法可以直接访问。
>
>4. 子类必须调用父类的构造器完成对父类的初始化当创建子类对象时，不管使用哪一个子类的构造器，默认情况下//super()；总会调用父类的无参构造器，如果父类没有提供无参构造器，则必须在子类中用super指定使用父类的哪个构造器完成对父类的初始化工作，否则，编译不通过。
>
>5. 如果希望调用父类的某个构造器，则显式的调用一下。
>
>6. super() 在调用时必须放在构造器的最前面。
>
>7. super()和this() 都只能放在构造器的第一行，因此这两个方法不能共存。
>
>8. 所有的类都是Object的子类。
>
>9. 父类构造器的调用不限于直接父类，将一直往上追溯到Object类。
>
>10. 子类最多只能有一个父类：单继承机制；
>
>11. 不能滥用继承，必须满足is-a 关系。
>
>12. 继承的内存分布：<img src="C:\Users\26251\AppData\Roaming\Typora\typora-user-images\image-20230925111323847.png" alt="image-20230925111323847" style="zoom:50%;" />
>
>13. 如上图所示：在调用一个属性时，要按照查找关系来返回信息的，
>
>    14. 首先看子类是否有这个属性；
>
>    15. 如果子类有这个属性，并且可以访问，则返回信息
>
>    16. 如果子类没有这个属性，就看父类有没有这个属性(如果父类有该属性并且可以访问，就返回)
>
>    17. 如果父类没有就按照3.的规则继续向上查找父类，知道Object...
>
>    18. #### 需要注意如果父类有该属性但被private起来他并不会跳过该父类继续向上，而是直接报错。

### super()

1. 代表父类的引用，用于访问父类的构造器，方法，属性

2. 访问父类的属性和方法，但不能访问private修饰的

3. super()的便利好处：

   1. 调用父类的构造器的好处，分工明确
   2. 当子类和父类的成员重名时，为了访问父类的成员，必须通过super。
   3. super() 的访问不限于直接父类，如果爷类和本类中有同名的成员，也可以使用super去访问爷爷类 的成员；如果 多个基类中都有同名的成员，使用时遵循就近原则，当然也需要遵守访问权限的相关规则。

### 方法重写

1. 子类的方法的参数和方法名称要和父类的一致，
2. 子类方法的返回类型和父类的返回类型一样，或者父类返回类型的子类。比如：父类返回类型是Object子类返回类型是String。
3. 子类方法不能缩小父类方法的访问权限。   

| 名称 | 发生范围                 | 方法名 | 参数列表 | 返回类型                                           | 修饰符                                 |
| ---- | ------------------------ | ------ | -------- | -------------------------------------------------- | -------------------------------------- |
| 重载 | 一个类中                 | 相同   | 必须不同 | 可以不同                                           | 无要求                                 |
| 重写 | 继承关系的子类和父类之间 | 相同   | 相同     | 可以不同，如果不同则子类必须返回父类返回类型的子类 | 可以不同，但子类不能缩小父类方法的权限 |

### 多态( polymorphic )

1. 方法和对象具有多种形态，是面向对象的第三大特征，多态是建立在封装和继承基础上的。

2. 方法重载体现多态；方法重写体现多态；

3. 对象的多态(核心)
   1. 一个对象的编译类型和运行类型可以不一致；
   2. 编译类型在定义对象时就确定了，不能改变，
   3. 运行类型时可以变化的。
   4. 编译类型看定义时 = 号的左边，运行类型看 = 的右边
   5. 笑话：披着羊皮的狼

4. 细节：

   1. 首先要存在继承关系

   2. 多态向上转型（父类的引用指向子类的对象，）

   3. 语法 ： 父类名  父类引用  = new 子类名() ；

   4. 可以调用父类的所有成员（遵守原则）

   5. 但是不能调用子类的特有成员； 因为在编译阶段能调用那些成员，是由编译类型决定的；

   6. 最终的运行结果还要看子类的具体实现；即调用方法时，从子类开始查找调用方法，就近原则

      ​	

5. 向下转型 

   1. 子类类型  引用名  = （子类类型） 父类引用
   2. 只能强制转父类的引用，不能强转父类的对象。
   3. 要求父类 的引用必须指向当前目标类型的对象
   4. 当向下转型后，就可以调用所有子类的成员。

6. 属性没有重写之说，属性看编译类型。

7. instanceOf() 比较操作符 ，判断对象XX(传入引用的运行类型)的类型是XX类型或者XX类型的子类型。

###  Java的动态绑定机制（DynamicBinding）重要

1. 当调用对象方法时，该方法会和该对象的内存地址/运行类型绑定
2. 当调用对象属性时，没有动态绑定机制，哪里声明那里使用。

---

#### 多态数组

1. 数组的定义为父类类型，里面保存的实际元素类型为子类类型  
2. 想调用子类特有的方法，可以使用 instanceOf() 语句进行判断。

#### 多态参数

1. 方法定义的形参类型是父类类型，实参允许可以为子类类型。

#### object类

1. equals(): 
   1. == 是一个比较运算符，即可以比较基本类型，也可以比较引用类型，如果判断基本类型，为值比较，如果判断引用类型，为地址比较，即判断是否是同一个对象。
   2. equals() 是object 的一个方法，只能判断引用类型，默认判断地址是否相同，子类中常常重写该方法，用于判断内容是否相等。
   3. 重写我们定义的类的equals()；
2. hashCode()；
   1. 提高具有哈希结构的容器的效率
   2. 两个引用，如果指向同一个对象，则哈希值肯定是一样的；
   3. 两个引用，如果指向的是不同对象，则哈希值是不一样的；
   4. 哈希值主要是根据地址号来的，不能完全将哈希值等同于地址。
   5. 后面在集合中hashCode()如果需要的话可以重写。

3. toString();
   1. 默认返回： 全类名+@+哈希值的十六进制，全类名指包名+类名
   2. 子类往往重写toString()方法, 用于返回对象的属性信息。
   3. 重写：快捷键
   4. 当直接输出一个对象时，默认调用toString();

4. finallize()
   1. 当对象被回收时，系统自动调用该对象的fianllize方法，子类可以重写该方法，做一些释放资源的操作；
   2. 什么时候被回收：当某个对象没有任何引用时，则jvm就认为这个对象是一个垃圾对象，就会使用垃圾回收机制来销毁对象，在销毁对象前，会先调用finallize方法
   3. 垃圾回收机制 的调用，是由系统决定的也可以由System.gc()主动触发垃圾回收机制
   4. 实际开发中几乎不会去运用


#### 断点调试

1. 快捷键： F7(跳入)	F8(跳过) 	F9(resume，执行下一个断点)
2. F7：跳入方法内
3. F8 : 跳出方法
4. 





## 提升编程能力



## 分析需求代码实现





